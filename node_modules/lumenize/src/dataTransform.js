// Generated by CoffeeScript 1.7.1
(function() {
  var JSON, Time, arrayOfMaps_To_CSVStyleArray, arrayOfMaps_To_HighChartsSeries, csvString_To_CSVStyleArray, csvStyleArray_To_ArrayOfMaps, csvStyleArray_To_CSVString, utils, _ref;

  _ref = require('tztime'), utils = _ref.utils, Time = _ref.Time;

  JSON = require('JSON2');

  csvStyleArray_To_ArrayOfMaps = function(csvStyleArray, rowKeys) {

    /*
    @method csvStyleArray_To_ArrayOfMaps
    @param {Array[]} csvStyleArray The first row is usually the list of column headers but if not, you can
      provide your own such list in the second parameter
    @param {String[]} [rowKeys] specify the column headers like `['column1', 'column2']`. If not provided, it will use
      the first row of the csvStyleArray
    @return {Object[]}
    
    `csvStyleArry_To_ArryOfMaps` is a convenience function that will convert a csvStyleArray like:
    
        {csvStyleArray_To_ArrayOfMaps} = require('../')
    
        csvStyleArray = [
          ['column1', 'column2'],
          [1         , 2       ],
          [3         , 4       ],
          [5         , 6       ]
        ]
    
    to an Array of Maps like this:
    
        console.log(csvStyleArray_To_ArrayOfMaps(csvStyleArray))
    
         * [ { column1: 1, column2: 2 },
         *   { column1: 3, column2: 4 },
         *   { column1: 5, column2: 6 } ]
    `
     */
    var arrayOfMaps, i, index, inputRow, key, outputRow, tableLength, _i, _len;
    arrayOfMaps = [];
    if (rowKeys != null) {
      i = 0;
    } else {
      rowKeys = csvStyleArray[0];
      i = 1;
    }
    tableLength = csvStyleArray.length;
    while (i < tableLength) {
      inputRow = csvStyleArray[i];
      outputRow = {};
      for (index = _i = 0, _len = rowKeys.length; _i < _len; index = ++_i) {
        key = rowKeys[index];
        outputRow[key] = inputRow[index];
      }
      arrayOfMaps.push(outputRow);
      i++;
    }
    return arrayOfMaps;
  };

  arrayOfMaps_To_CSVStyleArray = function(arrayOfMaps, keys) {

    /*
    @method arrayOfMaps_To_CSVStyleArray
    @param {Object[]} arrayOfMaps
    @param {Object} [keys] If not provided, it will use the first row and get all fields
    @return {Array[]} The first row will be the column headers
    
    `arrayOfMaps_To_CSVStyleArray` is a convenience function that will convert an array of maps like:
    
        {arrayOfMaps_To_CSVStyleArray} = require('../')
    
        arrayOfMaps = [
          {column1: 10000, column2: 20000},
          {column1: 30000, column2: 40000},
          {column1: 50000, column2: 60000}
        ]
    
    to a CSV-style array like this:
    
        console.log(arrayOfMaps_To_CSVStyleArray(arrayOfMaps))
    
         * [ [ 'column1', 'column2' ],
         *   [ 10000, 20000 ],
         *   [ 30000, 40000 ],
         *   [ 50000, 60000 ] ]
    `
     */
    var csvStyleArray, inRow, key, outRow, value, _i, _j, _len, _len1, _ref1;
    if (arrayOfMaps.length === 0) {
      return [];
    }
    csvStyleArray = [];
    outRow = [];
    if (keys == null) {
      keys = [];
      _ref1 = arrayOfMaps[0];
      for (key in _ref1) {
        value = _ref1[key];
        keys.push(key);
      }
    }
    csvStyleArray.push(keys);
    for (_i = 0, _len = arrayOfMaps.length; _i < _len; _i++) {
      inRow = arrayOfMaps[_i];
      outRow = [];
      for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
        key = keys[_j];
        outRow.push(inRow[key]);
      }
      csvStyleArray.push(outRow);
    }
    return csvStyleArray;
  };

  arrayOfMaps_To_HighChartsSeries = function(arrayOfMaps, config) {

    /*
    @method arrayOfMaps_To_HighChartsSeries
    @param {Array[]} arrayOfMaps
    @param {Object} config You can use the same config you used to call TimeSeriesCalculator including your yAxis specifications
    @return {Object[]} in HighCharts form
    
    Takes an array of arrays that came from a call to TimeSeriesCalculator and looks like this:
    
        {arrayOfMaps_To_HighChartsSeries} = require('../')
    
        arrayOfMaps = [
          {"Series 1": 8, "Series 2": 5, "Series3": 10},
          {"Series 1": 2, "Series 2": 3},
          {"Series 1": 1, "Series 2": 2, "Series3": 40},
        ]
    
    and a list of series configurations
    
        config = [
          {name: "Series 1", yAxis: 1},
          {name: "Series 2"},
          {name: "Series3"}
        ]
        
    and extracts the data into seperate series
    
        console.log(arrayOfMaps_To_HighChartsSeries(arrayOfMaps, config))
         * [ { name: 'Series 1', data: [ 8, 2, 1 ], yAxis: 1 },
         *   { name: 'Series 2', data: [ 5, 3, 2 ] },
         *   { name: 'Series3', data: [ 10, null, 40 ] } ]
        
    Notice how the extra fields from the series array are included in the output. Also, notice how the missing second
    value for Series3 was replaced with a null. HighCharts will skip right over this for category charts as you would
    expect.
     */
    var a, aggregationRow, idx, key, output, outputRow, preOutput, s, seriesNames, seriesRow, value, _i, _j, _k, _l, _len, _len1, _len2, _len3;
    preOutput = {};
    seriesNames = [];
    for (_i = 0, _len = config.length; _i < _len; _i++) {
      a = config[_i];
      seriesNames.push(a.name);
    }
    for (_j = 0, _len1 = seriesNames.length; _j < _len1; _j++) {
      s = seriesNames[_j];
      preOutput[s] = [];
      for (_k = 0, _len2 = arrayOfMaps.length; _k < _len2; _k++) {
        aggregationRow = arrayOfMaps[_k];
        value = aggregationRow[s];
        if (value == null) {
          value = null;
        }
        preOutput[s].push(value);
      }
    }
    output = [];
    for (idx = _l = 0, _len3 = seriesNames.length; _l < _len3; idx = ++_l) {
      s = seriesNames[idx];
      outputRow = {
        name: s,
        data: preOutput[s]
      };
      seriesRow = config[idx];
      for (key in seriesRow) {
        value = seriesRow[key];
        if (key !== 'name' && key !== 'data') {
          outputRow[key] = value;
        }
      }
      output.push(outputRow);
    }
    return output;
  };

  csvString_To_CSVStyleArray = function(s, asterixForUndefined) {
    var c, cValue, error, headerLength, index, newRow, out, rawRowArray, row, rows, _i, _j, _len, _len1;
    if (asterixForUndefined == null) {
      asterixForUndefined = true;
    }
    rows = s.split('\n');
    headerLength = rows[0].split(',').length;
    out = [];
    for (index = _i = 0, _len = rows.length; _i < _len; index = ++_i) {
      row = rows[index];
      newRow = [];
      rawRowArray = row.split(',');
      if (rawRowArray.length === headerLength) {
        for (_j = 0, _len1 = rawRowArray.length; _j < _len1; _j++) {
          c = rawRowArray[_j];
          if (asterixForUndefined && c === '*') {
            cValue = void 0;
          } else {
            try {
              cValue = JSON.parse(c);
            } catch (_error) {
              error = _error;
            }
          }
          newRow.push(cValue);
        }
        out.push(newRow);
      } else {
        console.log("Warning: Skipping row because length does not match header length in row " + index + ": " + row);
      }
    }
    return out;
  };

  csvStyleArray_To_CSVString = function(csvStyleArray) {
    var row, s, value, _i, _j, _len, _len1;
    s = '';
    for (_i = 0, _len = csvStyleArray.length; _i < _len; _i++) {
      row = csvStyleArray[_i];
      for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
        value = row[_j];
        s += JSON.stringify(value) + ', ';
      }
      s += "\n";
    }
    return s;
  };

  exports.arrayOfMaps_To_CSVStyleArray = arrayOfMaps_To_CSVStyleArray;

  exports.csvStyleArray_To_ArrayOfMaps = csvStyleArray_To_ArrayOfMaps;

  exports.arrayOfMaps_To_HighChartsSeries = arrayOfMaps_To_HighChartsSeries;

  exports.csvString_To_CSVStyleArray = csvString_To_CSVStyleArray;

  exports.csvStyleArray_To_CSVString = csvStyleArray_To_CSVString;

}).call(this);
