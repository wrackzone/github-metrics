// Generated by CoffeeScript 1.7.1
(function() {
  var CalculatorWithCallback4, DataFlow, NormalCalculator3a, callback, callback2, config, functionPlain1, functionThatReturnsResult3b, functionWithCallback2, functionWithoutParameters0, result0, result1;

  DataFlow = require('../').DataFlow;

  functionWithoutParameters0 = function() {
    return [
      {
        a: 1,
        b: 6
      }, {
        a: 10,
        b: 20
      }
    ];
  };

  functionPlain1 = function(data) {
    var row, _i, _len;
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      row = data[_i];
      row.c = row.a + row.b;
    }
    return data;
  };

  functionWithCallback2 = function(data, callback) {
    var row, sum, _i, _len;
    sum = 0;
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      row = data[_i];
      sum += row.c;
    }
    return callback(null, sum);
  };

  NormalCalculator3a = (function() {
    function NormalCalculator3a(config, data, sum) {
      this.config = config;
      this.data = data;
      this.sum = sum;
      this.results = [];
      this.addData(this.data);
    }

    NormalCalculator3a.prototype.addData = function(data) {
      var row, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        row = data[_i];
        _results.push(this.results.push(row.c / this.sum));
      }
      return _results;
    };

    NormalCalculator3a.prototype.getResults = function() {
      return this.results;
    };

    return NormalCalculator3a;

  })();

  functionThatReturnsResult3b = function(data) {
    var row, _i, _len;
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      row = data[_i];
      row.d = row.b - row.a;
    }
    return data;
  };

  CalculatorWithCallback4 = (function() {
    function CalculatorWithCallback4(config, data, data2, callback) {
      this.config = config;
      this.data = data;
      this.data2 = data2;
      this.callback = callback;
    }

    CalculatorWithCallback4.prototype.go = function() {
      var index, row, _i, _len, _ref;
      _ref = this.data;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        row = _ref[index];
        row.e = row.d + this.data2[index];
      }
      return this.callback(null, this.data);
    };

    return CalculatorWithCallback4;

  })();

  result0 = functionWithoutParameters0();

  result1 = functionPlain1(result0);

  callback2 = function(error, result) {
    var calculator3a, calculator4, callback4, result2, result3a, result3b;
    result2 = result;
    calculator3a = new NormalCalculator3a({}, result1, result2);
    result3a = calculator3a.getResults();
    result3b = functionThatReturnsResult3b(result1);
    callback4 = function(error, result) {
      var result4;
      result4 = result;
      return console.log(result4);
    };
    calculator4 = new CalculatorWithCallback4({}, result3b, result3a, callback4);
    return calculator4.go();
  };

  functionWithCallback2(result1, callback2);

  config = [
    {
      result0: functionWithoutParameters0,
      wrap: true
    }, {
      result1: functionPlain1,
      parameters: ['@result0'],
      wrap: true
    }, {
      result2: functionWithCallback2,
      parameters: ['@result1']
    }, {
      result3a: 'getResults',
      wrap: true,
      scopeClass: NormalCalculator3a,
      constructorParameters: [{}, '@result1', '@result2']
    }, {
      result3b: functionThatReturnsResult3b,
      parameters: ['@result1'],
      wrap: true
    }, {
      result4: 'go',
      scopeClass: CalculatorWithCallback4,
      constructorParameters: [{}, '@result3b', '@result3a']
    }
  ];


  /*
  Rather than make the user create the config and write their code, I'm looking to make Lumenize be a new reactive programming language.
  
  So, the user would type something like this:
  
  _@result0 = functionWithoutParameters0()
  _@result1 = functionPlain1(_@result0)
  _@result2 = functionWithCallback2(_@result1, _@)  # If you do this, the assumed callback pattern is cb(error, result)
  _@calculator3a = new NormalCalculator3a({}, _@result1, _@result2)
  _@result3a = _@calculator3a.getResults()
  _@result3b = functionThatReturnsResult3b(_@result1)
  _@calculator4 = new CalculatorWithCallback4({}, _@result3b, _@result3a, _@)
  _@result4 = _@calculator4.go()
  
  console.log(_@result4)
  
  -------
  
  We'd build the DAG from above.
  
  We'd rewrite a few things.
  
  First, any time it sees the _@ all by itself, that means that it's a callback. Everything below this point in the program is wrapped
  into a function and the function name is place in the position of the _@. Note the function gets moved above the call.
  
  Any line with a _@ to the left of an equals sign gets wrapped into it's own function along with every line of code that follows
  up to the next one. Question: how do we deal with scope? Will we have to declare those variables modified in the function outside
  the function so they are available to the next function? I think so. The functions all get called by the dispatcher based
  upon if the dependencies change.
   */

  callback = function(error, result) {
    if (error) {
      return console.log(error);
    } else {
      return console.log(result);
    }
  };

  exports.DataFlowTest = {
    testBasic: function(test) {
      DataFlow._addDependencies([], ['@dependency.fieldName']);
      return test.done();
    }
  };

}).call(this);
