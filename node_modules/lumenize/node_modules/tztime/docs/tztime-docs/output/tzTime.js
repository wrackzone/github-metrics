Ext.data.JsonP.tzTime({"tagname":"class","name":"tzTime","autodetected":{},"files":[{"filename":"tzTime.coffee.js","href":"tzTime.coffee.html#tzTime"}],"members":[],"alternateClassNames":[],"aliases":{},"id":"class-tzTime","short_doc":"tzTime\n\nTimezone transformations in the browser and node.js plus timezone precise timeline creation for charting. ...","component":false,"superclasses":[],"subclasses":[],"mixedInto":[],"mixins":[],"parentMixins":[],"requires":[],"uses":[],"html":"<div><pre class=\"hierarchy\"><h4>Files</h4><div class='dependency'><a href='source/tzTime.coffee.html#tzTime' target='_blank'>tzTime.coffee.js</a></div></pre><div class='doc-contents'><h1>tzTime</h1>\n\n<p><em>Timezone transformations in the browser and node.js plus timezone precise timeline creation for charting.</em></p>\n\n<h2>Features</h2>\n\n<ul>\n<li>Transform into and out of any timezone using Olson timezone rules</li>\n<li>Timezone rule files embedded in the minified browser package. No need to host them\nseperately.</li>\n<li><p>Create timezone precise time-series axis for charts</p>\n\n<ul>\n<li>Knockout weekends, holidays, non-workhours</li>\n<li>Work with timezone precision</li>\n<li><p>Work in any granularity</p>\n\n<ul>\n<li>Year, quarter, week, day, hour, etc.</li>\n<li>No more recording <code>2012-03-05T00:00:00.000Z</code> when you really just mean <code>2012-03-05</code></li>\n<li>Create and use custom granularities: <code>R02I04-07</code> = Seventh day of fourth iteration in\nsecond release</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Work in a particular granularity like day, week, month, or quarter and not worry about the fiddly bits of finer\ngranularity. JavaScript's Date object forces you to think about the fact that the underlying representation is milliseconds\nfrom the unix epoch.</p></li>\n<li>Month is 1-indexed (rather than 0-indexed like Javascript's Date object)</li>\n<li>Date/Time math (add 3 months, subtract 2 weeks, etc.)</li>\n<li><p>Work with ISO-8601 formatted strings (called 'ISOString' in this library)</p>\n\n<ul>\n<li>Added: Quarter form (e.g. 2012Q3 equates to 2012-07-01)</li>\n<li>Not supported: Ordinal form (e.g. 2012-001 for 2012-01-01, 2011-365 for 2012-12-31) not supported</li>\n</ul>\n</li>\n</ul>\n\n\n<h2>Granularity</h2>\n\n<p>Each Time object has a granularity. This means that you never have to\nworry about any bits lower than your specified granularity. A day has only\nyear, month, and day segments. You are never tempted to specify 11:59pm\nto specify the end of a day-long timebox.</p>\n\n<p>Time supports the following granularities:</p>\n\n<ul>\n<li><code>year</code>\n\n<ul>\n<li><code>month</code>\n\n<ul>\n<li><code>day</code>\n\n<ul>\n<li><code>hour</code>\n\n<ul>\n<li><code>minute</code>\n\n<ul>\n<li><code>second</code>\n\n<ul>\n<li><code>millisecond</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>quarter</code> (but not quarter_month, day, etc.)</li>\n<li><code>week</code> (ISO-8601 style week numbering)\n\n<ul>\n<li><code>week_day</code> (Monday = 1, Sunday = 7)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n\n<p>Also, you can define your own custom hierarchical granularities, for example...</p>\n\n<ul>\n<li><code>release</code>\n\n<ul>\n<li><code>iteration</code>\n\n<ul>\n<li><code>iteration_day</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n\n\n<h2>Timezone precision</h2>\n\n<p>It's very hard to do filtering and grouping of time-series data with timezone precision.</p>\n\n<p>For instance, 11pm in California on December 25 (Christmas holiday) is 2am December 26 (not a holiday)\nin New York. This also happens to be 7am December 26 GMT. If you have an event that occurs at\n2011-12-26T07:00:00.000Z, then you need to decide what timezone to use as your context before you\ndecide if that event occured on Christmas day or not. It's not just holidays where this can burn you.\nDeciding if a piece of work finished in one time range versus another can make a difference for\nyou metrics. The time range metrics for a distributed team should look the same regardless\nof whether those metrics were generated in New York versus Los Angeles... versus Bangalore.</p>\n\n<p>The javascript Date object lets you work in either the local time or Zulu (GMT/UTC) time but it doesn't let you\ncontrol the timezone. Do you know the correct way to apply the timezone shift to a JavaScript Date Object?\nDo you know when Daylight Savings Time kicks in and New York is 4 hours shifted from GMT instead of 5? Will\nyou remember to do it perfectly every time it's needed in your code?</p>\n\n<p>If you need this precision, Time helps by clearly delineating the moment when you need to do\ntimezone manipulation... the moment you need to compare/query timestamped data. You can do all of your\nholiday/weekend knockout manipulation without regard to timezone and only consider the timezone\nupon query submission or comparison.</p>\n\n<h2>Month is 1-indexed as you would expect</h2>\n\n<p>Javascript's date object uses 0 for January and 11 for December. Time uses 1 for January and 12 for December...\nwhich is what ISO-8601 uses and what humans expect. Everyone who works with the javascript Date Object at one\npoint or another gets burned by this.</p>\n\n<h2>Week support</h2>\n\n<p>Time has ISO-8601 week support. Implications of using this ISO format (paraphrased info from wikipedia):</p>\n\n<ul>\n<li>All weeks have 7 days (i.e. there are no fractional weeks).</li>\n<li>Any given day falls into a single week which means that incrementing across the year boundary in week\ngranularity is without gaps or repeats.</li>\n<li>Weeks are contained within a single year. (i.e. weeks are never spit over two years).</li>\n<li>The above two implications also mean that we have to warp the boundaries of the year to accomplish this. In week\ngranularity dates may appear in a different year than you would expect and some years have 53 weeks.</li>\n<li>The date directly tells the weekday.</li>\n<li>All years start with a Monday and end with a Sunday.</li>\n<li>Dates represented as yyyyWww-d can be sorted as strings.</li>\n</ul>\n\n\n<p><strong>In general, it just greatly simplifies the use of week granularity in a chart situation.</strong></p>\n\n<p>The ISO-8601 standard is an elegant and well thought out approach to dealing with week granularity. The only real\ndownside to this approach is that USA folks expect the week to start on Sunday. However, the ISO-8601 spec starts\neach week on Monday. Following ISO-8601, Time uses 1 for Monday and 7 for Sunday which aligns with\nthe US standard for every day except Sunday. The US standard is to use 0 for Sunday. This library says, \"tough luck\"\nto folks who are unhappy that the week starts on Monday. Live with the fact that weeks in this library start on Monday\nas they do in the ISO-8601 standard, or roll your own library. :-)</p>\n</div><div class='members'></div></div>","meta":{}});